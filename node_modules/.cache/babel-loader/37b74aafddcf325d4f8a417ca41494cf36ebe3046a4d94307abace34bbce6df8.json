{"ast":null,"code":"import { fabric } from 'fabric';\nexport class TemplateGenerator {\n  constructor(config) {\n    this.config = config;\n    this.canvas = null;\n  }\n  initCanvas(canvasElement) {\n    const canvasSize = this.config.getCanvasSize();\n    if (this.canvas) {\n      this.canvas.dispose();\n    }\n    this.canvas = new fabric.Canvas(canvasElement, {\n      width: canvasSize.width,\n      height: canvasSize.height,\n      backgroundColor: 'white',\n      selection: false\n    });\n    this.generateTemplate();\n    return this.canvas;\n  }\n  generateTemplate() {\n    if (!this.canvas) return;\n    this.canvas.clear();\n    this.canvas.backgroundColor = 'white';\n    const scale = 3.2; // Scale for screen display - better proportions for A4\n    const metrics = this.config.getCalculatedMetrics();\n    const canvasSize = this.config.getCanvasSize();\n\n    // Apply margins\n    const margins = {\n      top: this.config.margins.top * scale,\n      left: this.config.margins.left * scale,\n      right: this.config.margins.right * scale,\n      bottom: this.config.margins.bottom * scale\n    };\n    const workArea = {\n      width: canvasSize.width - margins.left - margins.right,\n      height: canvasSize.height - margins.top - margins.bottom\n    };\n\n    // Draw diagonal lines first (so they appear behind baselines)\n    if (this.config.showSlantLines) {\n      this.drawSlantLines(margins, workArea, metrics, scale);\n    }\n    this.drawBaselines(margins, workArea, metrics, scale);\n    if (this.config.showGrid) {\n      this.drawGrid(margins, workArea, scale);\n    }\n    this.canvas.renderAll();\n  }\n  drawBaselines(margins, workArea, metrics, scale) {\n    const lineSpacing = metrics.lineSpacing * scale;\n    const xHeight = metrics.xHeight * scale;\n    const capHeight = metrics.capHeight * scale;\n    const ascenderHeight = metrics.ascenderHeight * scale;\n    const descenderDepth = metrics.descenderDepth * scale;\n    const startY = margins.top + ascenderHeight;\n    const numberOfLines = Math.floor((workArea.height - ascenderHeight - descenderDepth) / lineSpacing);\n    for (let i = 0; i < numberOfLines; i++) {\n      const baselineY = startY + i * lineSpacing;\n\n      // Baseline (main writing line) - always show\n      this.addLine(margins.left, baselineY, margins.left + workArea.width, baselineY, {\n        stroke: this.config.baselineColor,\n        strokeWidth: 1.5\n      });\n\n      // Only show guide lines if enabled\n      if (this.config.showGuideLines) {\n        // X-height line\n        this.addLine(margins.left, baselineY - xHeight, margins.left + workArea.width, baselineY - xHeight, {\n          stroke: this.config.gridColor,\n          strokeWidth: 1,\n          opacity: 0.7\n        });\n\n        // Cap height line\n        this.addLine(margins.left, baselineY - capHeight, margins.left + workArea.width, baselineY - capHeight, {\n          stroke: this.config.gridColor,\n          strokeWidth: 1,\n          opacity: 0.7\n        });\n\n        // Ascender line\n        this.addLine(margins.left, baselineY - ascenderHeight, margins.left + workArea.width, baselineY - ascenderHeight, {\n          stroke: this.config.gridColor,\n          strokeWidth: 0.8,\n          opacity: 0.5\n        });\n\n        // Descender line\n        this.addLine(margins.left, baselineY + descenderDepth, margins.left + workArea.width, baselineY + descenderDepth, {\n          stroke: this.config.gridColor,\n          strokeWidth: 0.8,\n          opacity: 0.5\n        });\n      }\n    }\n  }\n  drawSlantLines(margins, workArea, metrics, scale) {\n    const slantAngle = metrics.slantAngle;\n    if (slantAngle === 0) return;\n    const radians = slantAngle * Math.PI / 180;\n    const slantSpacing = 4 * scale; // Much closer spacing - 4mm between lines\n    const numberOfVerticals = Math.floor(workArea.width / slantSpacing);\n    for (let i = 0; i <= numberOfVerticals; i++) {\n      const x = margins.left + i * slantSpacing;\n\n      // Calculate slanted line that goes through the entire height\n      const topY = margins.top;\n      const bottomY = margins.top + workArea.height;\n      const offset = workArea.height * Math.tan(radians);\n      this.addLine(x, topY, x + offset, bottomY, {\n        stroke: this.config.slantLineColor,\n        strokeWidth: 0.5,\n        opacity: 0.3,\n        strokeDashArray: [1, 2]\n      });\n    }\n  }\n  drawGrid(margins, workArea, scale) {\n    if (this.config.gridType === 'none') return;\n    const gridSpacing = 5 * scale; // 5mm grid\n    const isDotted = this.config.gridType === 'dotted';\n\n    // Vertical grid lines\n    for (let x = margins.left; x <= margins.left + workArea.width; x += gridSpacing) {\n      if (isDotted) {\n        this.addDottedLine(x, margins.top, x, margins.top + workArea.height);\n      } else {\n        this.addLine(x, margins.top, x, margins.top + workArea.height, {\n          stroke: this.config.gridColor,\n          strokeWidth: 0.3,\n          opacity: this.config.gridOpacity\n        });\n      }\n    }\n\n    // Horizontal grid lines\n    for (let y = margins.top; y <= margins.top + workArea.height; y += gridSpacing) {\n      if (isDotted) {\n        this.addDottedLine(margins.left, y, margins.left + workArea.width, y);\n      } else {\n        this.addLine(margins.left, y, margins.left + workArea.width, y, {\n          stroke: this.config.gridColor,\n          strokeWidth: 0.3,\n          opacity: this.config.gridOpacity\n        });\n      }\n    }\n  }\n  addLine(x1, y1, x2, y2, options = {}) {\n    const line = new fabric.Line([x1, y1, x2, y2], {\n      stroke: '#374151',\n      strokeWidth: 1,\n      selectable: false,\n      evented: false,\n      ...options\n    });\n    this.canvas.add(line);\n  }\n  addDottedLine(x1, y1, x2, y2) {\n    const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    const dotSpacing = 3;\n    const numberOfDots = Math.floor(distance / dotSpacing);\n    for (let i = 0; i <= numberOfDots; i++) {\n      const ratio = i / numberOfDots;\n      const x = x1 + (x2 - x1) * ratio;\n      const y = y1 + (y2 - y1) * ratio;\n      const dot = new fabric.Circle({\n        left: x - 0.5,\n        top: y - 0.5,\n        radius: 0.5,\n        fill: this.config.gridColor,\n        opacity: this.config.gridOpacity,\n        selectable: false,\n        evented: false\n      });\n      this.canvas.add(dot);\n    }\n  }\n  exportToDataURL() {\n    if (!this.canvas) return null;\n\n    // Temporarily scale up for high-resolution export\n    const originalWidth = this.canvas.width;\n    const originalHeight = this.canvas.height;\n    const scale = 10; // High resolution multiplier\n\n    this.canvas.setDimensions({\n      width: originalWidth * scale,\n      height: originalHeight * scale\n    });\n    this.canvas.setZoom(scale);\n    const dataURL = this.canvas.toDataURL({\n      format: 'png',\n      quality: 1,\n      multiplier: 1\n    });\n\n    // Restore original size\n    this.canvas.setDimensions({\n      width: originalWidth,\n      height: originalHeight\n    });\n    this.canvas.setZoom(1);\n    return dataURL;\n  }\n  destroy() {\n    if (this.canvas) {\n      this.canvas.dispose();\n      this.canvas = null;\n    }\n  }\n}","map":{"version":3,"names":["fabric","TemplateGenerator","constructor","config","canvas","initCanvas","canvasElement","canvasSize","getCanvasSize","dispose","Canvas","width","height","backgroundColor","selection","generateTemplate","clear","scale","metrics","getCalculatedMetrics","margins","top","left","right","bottom","workArea","showSlantLines","drawSlantLines","drawBaselines","showGrid","drawGrid","renderAll","lineSpacing","xHeight","capHeight","ascenderHeight","descenderDepth","startY","numberOfLines","Math","floor","i","baselineY","addLine","stroke","baselineColor","strokeWidth","showGuideLines","gridColor","opacity","slantAngle","radians","PI","slantSpacing","numberOfVerticals","x","topY","bottomY","offset","tan","slantLineColor","strokeDashArray","gridType","gridSpacing","isDotted","addDottedLine","gridOpacity","y","x1","y1","x2","y2","options","line","Line","selectable","evented","add","distance","sqrt","pow","dotSpacing","numberOfDots","ratio","dot","Circle","radius","fill","exportToDataURL","originalWidth","originalHeight","setDimensions","setZoom","dataURL","toDataURL","format","quality","multiplier","destroy"],"sources":["/Users/mikeyokei/Downloads/Drawing Sheet/src/utils/templateGenerator.js"],"sourcesContent":["import { fabric } from 'fabric';\n\nexport class TemplateGenerator {\n  constructor(config) {\n    this.config = config;\n    this.canvas = null;\n  }\n\n  initCanvas(canvasElement) {\n    const canvasSize = this.config.getCanvasSize();\n    \n    if (this.canvas) {\n      this.canvas.dispose();\n    }\n    \n    this.canvas = new fabric.Canvas(canvasElement, {\n      width: canvasSize.width,\n      height: canvasSize.height,\n      backgroundColor: 'white',\n      selection: false,\n    });\n    \n    this.generateTemplate();\n    return this.canvas;\n  }\n\n  generateTemplate() {\n    if (!this.canvas) return;\n    \n    this.canvas.clear();\n    this.canvas.backgroundColor = 'white';\n    \n    const scale = 3.2; // Scale for screen display - better proportions for A4\n    const metrics = this.config.getCalculatedMetrics();\n    const canvasSize = this.config.getCanvasSize();\n    \n    // Apply margins\n    const margins = {\n      top: this.config.margins.top * scale,\n      left: this.config.margins.left * scale,\n      right: this.config.margins.right * scale,\n      bottom: this.config.margins.bottom * scale,\n    };\n    \n    const workArea = {\n      width: canvasSize.width - margins.left - margins.right,\n      height: canvasSize.height - margins.top - margins.bottom,\n    };\n    \n    // Draw diagonal lines first (so they appear behind baselines)\n    if (this.config.showSlantLines) {\n      this.drawSlantLines(margins, workArea, metrics, scale);\n    }\n    \n    this.drawBaselines(margins, workArea, metrics, scale);\n    \n    if (this.config.showGrid) {\n      this.drawGrid(margins, workArea, scale);\n    }\n    \n    this.canvas.renderAll();\n  }\n\n  drawBaselines(margins, workArea, metrics, scale) {\n    const lineSpacing = metrics.lineSpacing * scale;\n    const xHeight = metrics.xHeight * scale;\n    const capHeight = metrics.capHeight * scale;\n    const ascenderHeight = metrics.ascenderHeight * scale;\n    const descenderDepth = metrics.descenderDepth * scale;\n    \n    const startY = margins.top + ascenderHeight;\n    const numberOfLines = Math.floor((workArea.height - ascenderHeight - descenderDepth) / lineSpacing);\n    \n    for (let i = 0; i < numberOfLines; i++) {\n      const baselineY = startY + (i * lineSpacing);\n      \n      // Baseline (main writing line) - always show\n      this.addLine(\n        margins.left,\n        baselineY,\n        margins.left + workArea.width,\n        baselineY,\n        { stroke: this.config.baselineColor, strokeWidth: 1.5 }\n      );\n      \n      // Only show guide lines if enabled\n      if (this.config.showGuideLines) {\n        // X-height line\n        this.addLine(\n          margins.left,\n          baselineY - xHeight,\n          margins.left + workArea.width,\n          baselineY - xHeight,\n          { stroke: this.config.gridColor, strokeWidth: 1, opacity: 0.7 }\n        );\n        \n        // Cap height line\n        this.addLine(\n          margins.left,\n          baselineY - capHeight,\n          margins.left + workArea.width,\n          baselineY - capHeight,\n          { stroke: this.config.gridColor, strokeWidth: 1, opacity: 0.7 }\n        );\n        \n        // Ascender line\n        this.addLine(\n          margins.left,\n          baselineY - ascenderHeight,\n          margins.left + workArea.width,\n          baselineY - ascenderHeight,\n          { stroke: this.config.gridColor, strokeWidth: 0.8, opacity: 0.5 }\n        );\n        \n        // Descender line\n        this.addLine(\n          margins.left,\n          baselineY + descenderDepth,\n          margins.left + workArea.width,\n          baselineY + descenderDepth,\n          { stroke: this.config.gridColor, strokeWidth: 0.8, opacity: 0.5 }\n        );\n      }\n    }\n  }\n\n  drawSlantLines(margins, workArea, metrics, scale) {\n    const slantAngle = metrics.slantAngle;\n    \n    if (slantAngle === 0) return;\n    \n    const radians = (slantAngle * Math.PI) / 180;\n    const slantSpacing = 4 * scale; // Much closer spacing - 4mm between lines\n    const numberOfVerticals = Math.floor(workArea.width / slantSpacing);\n    \n    for (let i = 0; i <= numberOfVerticals; i++) {\n      const x = margins.left + (i * slantSpacing);\n      \n      // Calculate slanted line that goes through the entire height\n      const topY = margins.top;\n      const bottomY = margins.top + workArea.height;\n      const offset = (workArea.height * Math.tan(radians));\n      \n      this.addLine(\n        x,\n        topY,\n        x + offset,\n        bottomY,\n        { \n          stroke: this.config.slantLineColor, \n          strokeWidth: 0.5, \n          opacity: 0.3,\n          strokeDashArray: [1, 2]\n        }\n      );\n    }\n  }\n\n  drawGrid(margins, workArea, scale) {\n    if (this.config.gridType === 'none') return;\n    \n    const gridSpacing = 5 * scale; // 5mm grid\n    const isDotted = this.config.gridType === 'dotted';\n    \n    // Vertical grid lines\n    for (let x = margins.left; x <= margins.left + workArea.width; x += gridSpacing) {\n      if (isDotted) {\n        this.addDottedLine(x, margins.top, x, margins.top + workArea.height);\n      } else {\n        this.addLine(\n          x,\n          margins.top,\n          x,\n          margins.top + workArea.height,\n          { \n            stroke: this.config.gridColor, \n            strokeWidth: 0.3, \n            opacity: this.config.gridOpacity \n          }\n        );\n      }\n    }\n    \n    // Horizontal grid lines\n    for (let y = margins.top; y <= margins.top + workArea.height; y += gridSpacing) {\n      if (isDotted) {\n        this.addDottedLine(margins.left, y, margins.left + workArea.width, y);\n      } else {\n        this.addLine(\n          margins.left,\n          y,\n          margins.left + workArea.width,\n          y,\n          { \n            stroke: this.config.gridColor, \n            strokeWidth: 0.3, \n            opacity: this.config.gridOpacity \n          }\n        );\n      }\n    }\n  }\n\n  addLine(x1, y1, x2, y2, options = {}) {\n    const line = new fabric.Line([x1, y1, x2, y2], {\n      stroke: '#374151',\n      strokeWidth: 1,\n      selectable: false,\n      evented: false,\n      ...options,\n    });\n    \n    this.canvas.add(line);\n  }\n\n  addDottedLine(x1, y1, x2, y2) {\n    const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    const dotSpacing = 3;\n    const numberOfDots = Math.floor(distance / dotSpacing);\n    \n    for (let i = 0; i <= numberOfDots; i++) {\n      const ratio = i / numberOfDots;\n      const x = x1 + (x2 - x1) * ratio;\n      const y = y1 + (y2 - y1) * ratio;\n      \n      const dot = new fabric.Circle({\n        left: x - 0.5,\n        top: y - 0.5,\n        radius: 0.5,\n        fill: this.config.gridColor,\n        opacity: this.config.gridOpacity,\n        selectable: false,\n        evented: false,\n      });\n      \n      this.canvas.add(dot);\n    }\n  }\n\n  exportToDataURL() {\n    if (!this.canvas) return null;\n    \n    // Temporarily scale up for high-resolution export\n    const originalWidth = this.canvas.width;\n    const originalHeight = this.canvas.height;\n    const scale = 10; // High resolution multiplier\n    \n    this.canvas.setDimensions({\n      width: originalWidth * scale,\n      height: originalHeight * scale,\n    });\n    \n    this.canvas.setZoom(scale);\n    \n    const dataURL = this.canvas.toDataURL({\n      format: 'png',\n      quality: 1,\n      multiplier: 1,\n    });\n    \n    // Restore original size\n    this.canvas.setDimensions({\n      width: originalWidth,\n      height: originalHeight,\n    });\n    \n    this.canvas.setZoom(1);\n    \n    return dataURL;\n  }\n\n  destroy() {\n    if (this.canvas) {\n      this.canvas.dispose();\n      this.canvas = null;\n    }\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}